/***************************************************************************

Gottlieb driver : dedicated to Warren Davis, Jeff Lee, Tim Skelly & David Thiel

driver by Fabrice Frances

Notes:
There was a bug in the hardware of the GG1 and GG2 boards, which is not
emulated. The bug seems to have disappeared with the later revision of the
board, e.g the board used by 3Stooges and Mach3 don't seem to have it).
The bug was affecting the first character column (on horizontal games):
screen memory could be used, but whatever was stored in this column, always
the same character was displayed.
This led to two consequences:
- the image on the monitor had to be stretched so that the column was not
  visible
- game designers were not using the first column. In fact, when the first
  column was ejected from the screen, the last one was usually out too,
  so it wasn't used either...

****************************************************************************

Reactor: earlier version of the board, with a different memory map

Main processor (8088 minimum mode)
0000-1fff RAM (NOT battery backed unlike all the others)
2000-2fff sprites
3000-37ff video ram
4000-4fff char generator ram
6000-67ff palette ram (palette of 16 colors)
7000-77ff i/o ports
8000-ffff ROM

memory mapped ports:

read:
7000    Dip switch
7001    Inputs 10-17
7002    trackball H
7003    trackball V
7004    Inputs 40-47

write:
7000    watchdog reset
7001    trackball clear
7002    Outputs 20-27
7003    Flipflop outputs:
		b0: F/B priority
		b1: horiz. flip
		b2: vert. flip
		b3: Output 33
		b4: coin counter
		b5: left lamp (1P/3Lives start)
		b6: middle lamps (2P/3Lives start, 1P/7Lives start)
		b7: right lamp (2P/7Lives start)
7004    Outputs 40-47

interrupts:
INTR not connected
NMI connected to vertical blank



Gottlieb games memory map

Main processor (8088 minimum mode)
0000-0fff RAM (battery backed)
1000-1fff RAM or ROM (selected with jumpers on the board)
2000-2fff RAM or ROM (selected with jumpers on the board)
3000-37ff sprites. The manual says there are 63 sprites (NOT 64),
          but the Q*Bert object priority test leaves sprite #63 dangling, so
		  they are probably only 62.
3800-3fff video RAM
4000-4fff char generator RAM (can be replaced by a ROM twice as large,
          selection made with jumpers on the board. If it's ROM, the CPU
		  cannot fully access it, I think it could read half the data if it
		  wanted to but none of the games do that)
5000-57ff palette ram (palette of 16 colors)
5800-5fff i/o ports
6000-ffff ROM (not necessarily fully populated)

memory mapped ports:

read:
5800    Dip switch
5801    Inputs 10-17
5802    trackball H (optional)
5803    trackball V (optional)
5804    Inputs 40-47

write:
5800    watchdog reset
5801    trackball clear (optional)
5802    Outputs 20-27
5803    Flipflop outputs:
		b0: F/B priority
		b1: horiz. flip (sprite bank in Us vs. Them)
		b2: vert. flip (maybe genlock control in the laser disc games)
		b3: Output 33
		b4: coin counter (sprite bank in Q*Bert Qubes)
		b5: Q*Bert: kicker; Q*Bert Qubes: coin counter
		b5/b6: 3 Stooges: joystick input multiplexer
		b7: ?
5804    Outputs 40-47

interrupts:
INTR not connected
NMI connected to vertical blank



Sound processor (6502) memory map (earlier revision, used by games up to Krull):
0000-0fff RIOT (6532)
1000-1fff amplitude DAC
2000-2fff SC01 voice chip
3000-3fff voice clock DAC
4000-4fff expansion socket
5000-5fff expansion socket
6000-6fff expansion socket or ROM (selected with jumpers on the board)
7000-7fff ROM
(repeated in 8000-ffff, A15 only used in expansion socket)

Use of I/Os on the RIOT:
both ports A and B are programmed as inputs, A is connected to the main
motherboard, and B has SW1 (test) connected on bit 6.

interrupts:
INTR is connected to the RIOT, so an INTR can be generated by a variety
of sources, e.g active edge detection on PA7, or timer countdown.
It seems that all gottlieb games program the interrupt conditions so that
a positive active edge on PA7 triggers an interrupt, so the
main board ensures a command is correctly received by sending nul (0)
commands between two commands. Also, the timer interrupt is enabled but
doesn't seem to serve any purpose...(?)


In the later revision of the sound board, used from M.A.C.H. 3 onwards, there
are two 6502, two 8910, a DAC and a GI SP-0250 speech chip.


Video timings:
XTAL = 20 MHz
Horizontal video frequency: HSYNC = XTAL/4/318 = 15.72327 kHz
Video frequency: VSYNC = HSYNC/256 = 61.41903 Hz
VBlank duration: 1/VSYNC * (16/256) = 1017.6 us

***************************************************************************/

/*
 * ported to v0.37b7
 * using automatic conversion tool v0.01
 */ 
package drivers;

public class gottlieb
{
	
	
	
	extern UBytePtr gottlieb_characterram;
	
	
	extern UBytePtr riot_ram;
	
	
	static public static InitMachinePtr init_machine = new InitMachinePtr() { public void handler() 
	{
		UINT8 *ram = memory_region(REGION_CPU1);
		cpu_setbank(1, &ram[0x8000]);
		cpu_setbank(2, &ram[0x0000]);
	} };
	
	
	static int track[2];
	
	public static ReadHandlerPtr gottlieb_track_0_r  = new ReadHandlerPtr() { public int handler(int offset)
	{
		return input_port_2_r.handler(offset) - track[0];
	} };
	
	public static ReadHandlerPtr gottlieb_track_1_r  = new ReadHandlerPtr() { public int handler(int offset)
	{
		return input_port_3_r.handler(offset) - track[1];
	} };
	
	public static WriteHandlerPtr gottlieb_track_reset_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		/* reset the trackball counters */
		track[0] = input_port_2_r(offset);
		track[1] = input_port_3_r(offset);
	} };
	
	static int joympx;
	
	public static ReadHandlerPtr stooges_IN4_r  = new ReadHandlerPtr() { public int handler(int offset)
	{
		int joy;
	
	
		switch (joympx)
		{
			case 0:
			default:
				joy = ((readinputport(4) >> 0) & 0x0f);	/* joystick 1 */
				break;
			case 1:
				joy = ((readinputport(5) >> 0) & 0x0f);	/* joystick 2 */
				break;
			case 2:
				joy = ((readinputport(5) >> 4) & 0x0f);	/* joystick 3 */
				break;
		}
	
		return joy | (readinputport(4) & 0xf0);
	} };
	
	public static WriteHandlerPtr reactor_output_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		set_led_status(0,data & 0x20);
		set_led_status(1,data & 0x40);
		set_led_status(2,data & 0x80);
		gottlieb_video_outputs_w(offset,data);
	} };
	
	public static WriteHandlerPtr stooges_output_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		joympx = (data >> 5) & 0x03;
		gottlieb_video_outputs_w(offset,data);
	} };
	
	
	static int current_frame = 0x00001;
	static int laserdisc_playing;
	static int lasermpx;
	
	public static ReadHandlerPtr gottlieb_laserdisc_status_r  = new ReadHandlerPtr() { public int handler(int offset)
	{
		switch (offset)
		{
			case 0:
				return (current_frame >> 0) & 0xff;
				break;
			case 1:
				return (current_frame >> 8) & 0xff;
				break;
			case 2:
				if (lasermpx == 1)
					/* bits 0-2 frame number MSN */
					/* bit 3 audio buffer ready */
					/* bit 4 ready to send new laserdisc command? */
					/* bit 5 disc ready */
					/* bit 6 break in audio trasmission */
					/* bit 7 missing audio clock */
					return ((current_frame >> 16) & 0x07) | 0x10 | (rand() & 0x28);
				else	/* read audio buffer */
					return rand();
				break;
		}
	
		return 0;
	} };
	
	public static WriteHandlerPtr gottlieb_laserdisc_mpx_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		lasermpx = data & 1;
	} };
	
	public static WriteHandlerPtr gottlieb_laserdisc_command_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		static int loop;
		int cmd;
		static int lastcmd;
	
	
		/* commands are written in three steps, the first two the command is */
		/* written (maybe one to load the latch, the other to start the send), */
		/* the third 0 (maybe to clear the latch) */
		if (data == 0) return;
		if (loop++ & 1) return;
	
		if ((data & 0xe0) != 0x20)
		{
	logerror("error: laserdisc command %02x\n",data);
			return;
		}
	
		cmd =	((data & 0x10) >> 4) |
				((data & 0x08) >> 2) |
				((data & 0x04) >> 0) |
				((data & 0x02) << 2) |
				((data & 0x01) << 4);
	
	logerror("laserdisc command %02x . %02x\n",data,cmd);
		if (lastcmd == 0x0b && (cmd & 0x10))	/* seek frame # */
		{
			current_frame = (current_frame << 4) | (cmd & 0x0f);
		}
		else
		{
			if (cmd == 0x04)	/* step forward */
			{
				laserdisc_playing = 0;
				current_frame++;
			}
			if (cmd == 0x05) laserdisc_playing = 1;	/* play */
			if (cmd == 0x0f) laserdisc_playing = 0;	/* stop */
			if (cmd == 0x0b) laserdisc_playing = 0;	/* seek frame */
			lastcmd = cmd;
		}
	} };
	
	public static InterruptPtr gottlieb_interrupt = new InterruptPtr() { public int handler() 
	{
		if (laserdisc_playing != 0) current_frame++;
	
		return nmi_interrupt();
	} };
	
	
	static UBytePtr nvram;
	static size_t nvram_size;
	
	public static nvramPtr nvram_handler  = new nvramPtr() { public void handler(Object file, int read_or_write) 
	{
		if (read_or_write != 0)
			osd_fwrite(file,nvram,nvram_size);
		else
		{
			if (file != 0)
				osd_fread(file,nvram,nvram_size);
			else
				memset(nvram,0xff,nvram_size);
		}
	} };
	
	
	
	static MemoryReadAddress reactor_readmem[] =
	{
		new MemoryReadAddress( 0x00000, 0x01fff, MRA_RAM ),
		new MemoryReadAddress( 0x03000, 0x033ff, MRA_RAM ),
		new MemoryReadAddress( 0x04000, 0x04fff, MRA_RAM ),
		new MemoryReadAddress( 0x07000, 0x07000, input_port_0_r ),	/* DSW */
		new MemoryReadAddress( 0x07001, 0x07001, input_port_1_r ),	/* buttons */
		new MemoryReadAddress( 0x07002, 0x07002, gottlieb_track_0_r ),	/* trackball H */
		new MemoryReadAddress( 0x07003, 0x07003, gottlieb_track_1_r ),	/* trackball V */
		new MemoryReadAddress( 0x07004, 0x07004, input_port_4_r ),	/* joystick */
		new MemoryReadAddress( 0x08000, 0x0ffff, MRA_ROM ),
		/* map the ROM into Fxxxx so we can boot */
		new MemoryReadAddress( 0xf8000, 0xfffff, MRA_BANK1 ),
		new MemoryReadAddress( -1 )  /* end of table */
	};
	
	static MemoryWriteAddress reactor_writemem[] =
	{
		new MemoryWriteAddress( 0x00000, 0x01fff, MWA_RAM ),
		new MemoryWriteAddress( 0x02000, 0x020ff, MWA_RAM, spriteram, spriteram_size ),
		new MemoryWriteAddress( 0x03000, 0x033ff, videoram_w, videoram, videoram_size ),
		new MemoryWriteAddress( 0x03400, 0x037ff, videoram_w ),	/* mirror address, some games write to it */
		new MemoryWriteAddress( 0x04000, 0x04fff, gottlieb_characterram_w, gottlieb_characterram ),
		new MemoryWriteAddress( 0x06000, 0x0601f, gottlieb_paletteram_w, paletteram ),
		new MemoryWriteAddress( 0x07000, 0x07000, watchdog_reset_w ),
		new MemoryWriteAddress( 0x07001, 0x07001, gottlieb_track_reset_w ),
		new MemoryWriteAddress( 0x07002, 0x07002, gottlieb_sh_w ), /* sound/speech command */
		new MemoryWriteAddress( 0x07003, 0x07003, reactor_output_w ),       /* OUT1 */
		new MemoryWriteAddress( 0x08000, 0x0ffff, MWA_ROM ),
		new MemoryWriteAddress( -1 )  /* end of table */
	};
	
	static MemoryReadAddress gottlieb_readmem[] =
	{
		new MemoryReadAddress( 0x00000, 0x00fff, MRA_RAM ),
		new MemoryReadAddress( 0x01000, 0x01fff, MRA_RAM ),	/* or ROM */
		new MemoryReadAddress( 0x02000, 0x02fff, MRA_RAM ),	/* or ROM */
		new MemoryReadAddress( 0x03800, 0x03bff, MRA_RAM ),
		new MemoryReadAddress( 0x04000, 0x04fff, MRA_RAM ),
		new MemoryReadAddress( 0x05800, 0x05800, input_port_0_r ),	/* DSW */
		new MemoryReadAddress( 0x05801, 0x05801, input_port_1_r ),	/* buttons */
		new MemoryReadAddress( 0x05802, 0x05802, gottlieb_track_0_r ),	/* trackball H */
		new MemoryReadAddress( 0x05803, 0x05803, gottlieb_track_1_r ),	/* trackball V */
		new MemoryReadAddress( 0x05804, 0x05804, input_port_4_r ),	/* joystick */
		new MemoryReadAddress( 0x05805, 0x05807, gottlieb_laserdisc_status_r ),
		new MemoryReadAddress( 0x06000, 0x0ffff, MRA_ROM ),
		/* Us vs Them and Q*bert Qubes use the Exxxx address space */
		new MemoryReadAddress( 0xe5800, 0xe5800, input_port_0_r ),	/* DSW */
		new MemoryReadAddress( 0xe5801, 0xe5801, input_port_1_r ),	/* buttons */
		new MemoryReadAddress( 0xe5802, 0xe5802, gottlieb_track_0_r ),	/* trackball H */
		new MemoryReadAddress( 0xe5803, 0xe5803, gottlieb_track_1_r ),	/* trackball V */
		new MemoryReadAddress( 0xe5804, 0xe5804, input_port_4_r ),	/* joystick */
		new MemoryReadAddress( 0xe5805, 0xe5807, gottlieb_laserdisc_status_r ),
		new MemoryReadAddress( 0xe0000, 0xeffff, MRA_BANK2 ),
		/* map the ROM into Fxxxx so we can boot */
		new MemoryReadAddress( 0xf8000, 0xfffff, MRA_BANK1 ),
		new MemoryReadAddress( -1 )  /* end of table */
	};
	
	static MemoryWriteAddress gottlieb_writemem[] =
	{
		new MemoryWriteAddress( 0x00000, 0x00fff, MWA_RAM, nvram, nvram_size ),
		new MemoryWriteAddress( 0x01000, 0x01fff, MWA_RAM ),	/* ROM in Krull */
		new MemoryWriteAddress( 0x02000, 0x02fff, MWA_RAM ),	/* ROM in Krull and 3 Stooges */
		new MemoryWriteAddress( 0x03000, 0x030ff, MWA_RAM, spriteram, spriteram_size ),
		new MemoryWriteAddress( 0x03800, 0x03bff, videoram_w, videoram, videoram_size ),
		new MemoryWriteAddress( 0x03c00, 0x03fff, videoram_w ),	/* mirror address, some games write to it */
		new MemoryWriteAddress( 0x04000, 0x04fff, gottlieb_characterram_w, gottlieb_characterram ),
		new MemoryWriteAddress( 0x05000, 0x0501f, gottlieb_paletteram_w, paletteram ),
		new MemoryWriteAddress( 0x05800, 0x05800, watchdog_reset_w ),
		new MemoryWriteAddress( 0x05801, 0x05801, gottlieb_track_reset_w ),
		new MemoryWriteAddress( 0x05802, 0x05802, gottlieb_sh_w ), /* sound/speech command */
		new MemoryWriteAddress( 0x05803, 0x05803, gottlieb_video_outputs_w ),       /* OUT1 */
		new MemoryWriteAddress( 0x06000, 0x0ffff, MWA_ROM ),
		/* Q*bert Qubes uses the Exxxx address space */
		new MemoryWriteAddress( 0xe0000, 0xe37ff, MWA_BANK2 ),
		new MemoryWriteAddress( 0xe3800, 0xe3bff, videoram_w ),
		new MemoryWriteAddress( 0xe3c00, 0xe3fff, videoram_w ),	/* mirror address, some games write to it */
		new MemoryWriteAddress( 0xe4000, 0xe4fff, gottlieb_characterram_w ),
		new MemoryWriteAddress( 0xe5000, 0xe501f, gottlieb_paletteram_w ),
		new MemoryWriteAddress( 0xe5800, 0xe5800, watchdog_reset_w ),
		new MemoryWriteAddress( 0xe5801, 0xe5801, gottlieb_track_reset_w ),
		new MemoryWriteAddress( 0xe5802, 0xe5802, gottlieb_sh_w ), /* sound/speech command */
		new MemoryWriteAddress( 0xe5803, 0xe5803, gottlieb_video_outputs_w ),       /* OUT1 */
		new MemoryWriteAddress( -1 )  /* end of table */
	};
	
	
	/* same as above, different video_outputs plus laser disc control outputs */
	static MemoryWriteAddress usvsthem_writemem[] =
	{
		new MemoryWriteAddress( 0x00000, 0x00fff, MWA_RAM, nvram, nvram_size ),
		new MemoryWriteAddress( 0x01000, 0x01fff, MWA_RAM ),	/* ROM in Krull */
		new MemoryWriteAddress( 0x02000, 0x02fff, MWA_RAM ),	/* ROM in Krull and 3 Stooges */
		new MemoryWriteAddress( 0x03000, 0x030ff, MWA_RAM, spriteram, spriteram_size ),
		new MemoryWriteAddress( 0x03800, 0x03bff, videoram_w, videoram, videoram_size ),
		new MemoryWriteAddress( 0x03c00, 0x03fff, videoram_w ),	/* mirror address, some games write to it */
		new MemoryWriteAddress( 0x04000, 0x04fff, gottlieb_characterram_w, gottlieb_characterram ),
		new MemoryWriteAddress( 0x05000, 0x0501f, gottlieb_paletteram_w, paletteram ),
		new MemoryWriteAddress( 0x05800, 0x05800, watchdog_reset_w ),
		new MemoryWriteAddress( 0x05801, 0x05801, gottlieb_track_reset_w ),
		new MemoryWriteAddress( 0x05802, 0x05802, gottlieb_sh_w ), /* sound/speech command */
		new MemoryWriteAddress( 0x05803, 0x05803, usvsthem_video_outputs_w ),       /* OUT1 */
		new MemoryWriteAddress( 0x05805, 0x05805, gottlieb_laserdisc_command_w ),	/* command for the player */
		new MemoryWriteAddress( 0x05806, 0x05806, gottlieb_laserdisc_mpx_w ),
		new MemoryWriteAddress( 0x06000, 0x0ffff, MWA_ROM ),
		/* Us vs Them uses the Exxxx address space */
		new MemoryWriteAddress( 0xe0000, 0xe37ff, MWA_BANK2 ),
		new MemoryWriteAddress( 0xe3800, 0xe3bff, videoram_w ),
		new MemoryWriteAddress( 0xe3c00, 0xe3fff, videoram_w ),	/* mirror address, some games write to it */
		new MemoryWriteAddress( 0xe4000, 0xe4fff, gottlieb_characterram_w ),
		new MemoryWriteAddress( 0xe5000, 0xe501f, gottlieb_paletteram_w ),
		new MemoryWriteAddress( 0xe5800, 0xe5800, watchdog_reset_w ),
		new MemoryWriteAddress( 0xe5801, 0xe5801, gottlieb_track_reset_w ),
		new MemoryWriteAddress( 0xe5802, 0xe5802, gottlieb_sh_w ), /* sound/speech command */
		new MemoryWriteAddress( 0xe5803, 0xe5803, usvsthem_video_outputs_w ),       /* OUT1 */
		new MemoryWriteAddress( 0xe5805, 0xe5805, gottlieb_laserdisc_command_w ),	/* command for the player */
		new MemoryWriteAddress( 0xe5806, 0xe5806, gottlieb_laserdisc_mpx_w ),
		new MemoryWriteAddress( -1 )  /* end of table */
	};
	
	/* same as above, different IN4 */
	static MemoryReadAddress stooges_readmem[] =
	{
		new MemoryReadAddress( 0x00000, 0x00fff, MRA_RAM ),
		new MemoryReadAddress( 0x01000, 0x01fff, MRA_RAM ),
		new MemoryReadAddress( 0x02000, 0x02fff, MRA_ROM ),
		new MemoryReadAddress( 0x03800, 0x03bff, MRA_RAM ),
		new MemoryReadAddress( 0x04000, 0x04fff, MRA_RAM ),
		new MemoryReadAddress( 0x05800, 0x05800, input_port_0_r ),	/* DSW */
		new MemoryReadAddress( 0x05801, 0x05801, input_port_1_r ),	/* buttons */
		new MemoryReadAddress( 0x05802, 0x05802, gottlieb_track_0_r ),	/* trackball H */
		new MemoryReadAddress( 0x05803, 0x05803, gottlieb_track_1_r ),	/* trackball V */
		new MemoryReadAddress( 0x05804, 0x05804, stooges_IN4_r ),	/* joystick */
		new MemoryReadAddress( 0x06000, 0x0ffff, MRA_ROM ),
		/* map the ROM into Fxxxx so we can boot */
		new MemoryReadAddress( 0xf8000, 0xfffff, MRA_BANK1 ),
		new MemoryReadAddress( -1 )  /* end of table */
	};
	
	/* same as above, different video_outputs */
	static MemoryWriteAddress stooges_writemem[] =
	{
		new MemoryWriteAddress( 0x00000, 0x00fff, MWA_RAM, nvram, nvram_size ),
		new MemoryWriteAddress( 0x01000, 0x01fff, MWA_RAM ),
		new MemoryWriteAddress( 0x02000, 0x02fff, MWA_ROM ),
		new MemoryWriteAddress( 0x03000, 0x030ff, MWA_RAM, spriteram, spriteram_size ),
		new MemoryWriteAddress( 0x03800, 0x03bff, videoram_w, videoram, videoram_size ),
		new MemoryWriteAddress( 0x03c00, 0x03fff, videoram_w ),	/* mirror address, some games write to it */
		new MemoryWriteAddress( 0x04000, 0x04fff, gottlieb_characterram_w, gottlieb_characterram ),
		new MemoryWriteAddress( 0x05000, 0x0501f, gottlieb_paletteram_w, paletteram ),
		new MemoryWriteAddress( 0x05800, 0x05800, watchdog_reset_w ),
		new MemoryWriteAddress( 0x05801, 0x05801, gottlieb_track_reset_w ),
		new MemoryWriteAddress( 0x05802, 0x05802, gottlieb_sh_w ), /* sound/speech command */
		new MemoryWriteAddress( 0x05803, 0x05803, stooges_output_w ),       /* OUT1 */
		new MemoryWriteAddress( 0x06000, 0x0ffff, MWA_ROM ),
		new MemoryWriteAddress( -1 )  /* end of table */
	};
	
	
	
	static MemoryReadAddress gottlieb_sound_readmem[] =
	{
		new MemoryReadAddress( 0x0000, 0x01ff, riot_ram_r ),
		new MemoryReadAddress( 0x0200, 0x03ff, gottlieb_riot_r ),
		new MemoryReadAddress( 0x6000, 0x7fff, MRA_ROM ),
				 /* A15 not decoded except in expansion socket */
		new MemoryReadAddress( 0x8000, 0x81ff, riot_ram_r ),
		new MemoryReadAddress( 0x8200, 0x83ff, gottlieb_riot_r ),
		new MemoryReadAddress( 0xe000, 0xffff, MRA_ROM ),
		new MemoryReadAddress( -1 )  /* end of table */
	};
	
	static MemoryWriteAddress gottlieb_sound_writemem[] =
	{
		new MemoryWriteAddress( 0x0000, 0x01ff, riot_ram_w, riot_ram ),
		new MemoryWriteAddress( 0x0200, 0x03ff, gottlieb_riot_w ),
		new MemoryWriteAddress( 0x1000, 0x1000, DAC_0_data_w ),
		new MemoryWriteAddress( 0x2000, 0x2000, gottlieb_speech_w ),
		new MemoryWriteAddress( 0x3000, 0x3000, gottlieb_speech_clock_DAC_w ),
		new MemoryWriteAddress( 0x6000, 0x7fff, MWA_ROM ),
				 /* A15 not decoded except in expansion socket */
		new MemoryWriteAddress( 0x8000, 0x81ff, riot_ram_w ),
		new MemoryWriteAddress( 0x8200, 0x83ff, gottlieb_riot_w ),
		new MemoryWriteAddress( 0x9000, 0x9000, DAC_0_data_w ),
		new MemoryWriteAddress( 0xa000, 0xa000, gottlieb_speech_w ),
		new MemoryWriteAddress( 0xb000, 0xb000, gottlieb_speech_clock_DAC_w ),
		new MemoryWriteAddress( 0xe000, 0xffff, MWA_ROM ),
		new MemoryWriteAddress( -1 )  /* end of table */
	};
	
	
	static MemoryReadAddress stooges_sound_readmem[] =
	{
		new MemoryReadAddress( 0x0000, 0x03ff, MRA_RAM ),
		new MemoryReadAddress( 0x8000, 0x8000, soundlatch_r ),
		new MemoryReadAddress( 0xe000, 0xffff, MRA_ROM ),
		new MemoryReadAddress( -1 )  /* end of table */
	};
	
	static MemoryWriteAddress stooges_sound_writemem[] =
	{
		new MemoryWriteAddress( 0x0000, 0x03ff, MWA_RAM ),
		new MemoryWriteAddress( 0x4000, 0x4001, DAC_0_data_w ),
		new MemoryWriteAddress( 0xe000, 0xffff, MWA_ROM ),
		new MemoryWriteAddress( -1 )  /* end of table */
	};
	
	
	static MemoryReadAddress stooges_sound2_readmem[] =
	{
		new MemoryReadAddress( 0x0000, 0x03ff, MRA_RAM ),
		new MemoryReadAddress( 0x6000, 0x6000, stooges_sound_input_r ),	/* various signals */
		new MemoryReadAddress( 0xa800, 0xa800, soundlatch_r ),
		new MemoryReadAddress( 0xc000, 0xffff, MRA_ROM ),
		new MemoryReadAddress( -1 )  /* end of table */
	};
	
	static MemoryWriteAddress stooges_sound2_writemem[] =
	{
		new MemoryWriteAddress( 0x0000, 0x03ff, MWA_RAM ),
		new MemoryWriteAddress( 0x2000, 0x2000, MWA_NOP ),	/* speech chip. The game sends strings */
										/* of 15 bytes (clocked by 4000). The chip also */
										/* checks a DATA REQUEST bit in 6000. */
		new MemoryWriteAddress( 0x4000, 0x4000, stooges_sound_control_w ),
		new MemoryWriteAddress( 0x8000, 0x8000, stooges_8910_latch_w ),
		new MemoryWriteAddress( 0xa000, 0xa000, gottlieb_nmi_rate_w ),	/* the timer generates NMIs */
		new MemoryWriteAddress( 0xb000, 0xb000, gottlieb_cause_dac_nmi_w ),
		new MemoryWriteAddress( 0xc000, 0xffff, MWA_ROM ),
		new MemoryWriteAddress( -1 )  /* end of table */
	};
	
	
	
	static InputPortPtr input_ports_reactor = new InputPortPtr(){ public void handler() { 
	PORT_START(); 	/* DSW */
		PORT_DIPNAME( 0x01, 0x01, "Sound with Logos" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x01, DEF_STR( "On") );
		PORT_DIPNAME( 0x02, 0x02, "Bounce Chambers Points" );	PORT_DIPSETTING(    0x00, "10" );	PORT_DIPSETTING(    0x02, "15" );	PORT_DIPNAME( 0x04, 0x04, DEF_STR( "Free_Play") );
		PORT_DIPSETTING(    0x04, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x00, DEF_STR( "On") );
		PORT_DIPNAME( 0x08, 0x08, "Sound with Instructions" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x08, DEF_STR( "On") );
		PORT_DIPNAME( 0x10, 0x10, DEF_STR( "Cabinet") );
		PORT_DIPSETTING(    0x10, DEF_STR( "Upright") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Cocktail") );
		PORT_DIPNAME( 0x20, 0x20, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x00, DEF_STR( "2C_1C") );
		PORT_DIPSETTING(    0x20, DEF_STR( "1C_1C") );
		PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( "Bonus_Life") );
		PORT_DIPSETTING(    0x00, "10000" );	PORT_DIPSETTING(    0x40, "12000" );	PORT_DIPSETTING(    0xc0, "15000" );	PORT_DIPSETTING(    0x80, "20000" );
		PORT_START(); 	/* IN1 */
		PORT_BITX(0x01, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_SERVICE( 0x02, IP_ACTIVE_LOW );	PORT_BIT ( 0xfc, IP_ACTIVE_HIGH, IPT_UNKNOWN );
		PORT_START(); 	/* trackball H */
		PORT_ANALOG( 0xff, 0, IPT_TRACKBALL_X, 15, 20, 0, 0 );
		PORT_START(); 	/* trackball V */
		PORT_ANALOG( 0xff, 0, IPT_TRACKBALL_Y, 15, 20, 0, 0 );
		PORT_START(); 	/* IN4 */
		PORT_BIT ( 0x01, IP_ACTIVE_HIGH, IPT_START1 );	PORT_BIT ( 0x02, IP_ACTIVE_HIGH, IPT_START2 );	PORT_BIT ( 0x04, IP_ACTIVE_HIGH, IPT_BUTTON2 );	PORT_BIT ( 0x08, IP_ACTIVE_HIGH, IPT_BUTTON1 );	PORT_BIT ( 0x10, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT ( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT ( 0xc0, IP_ACTIVE_HIGH, IPT_UNKNOWN );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_mplanets = new InputPortPtr(){ public void handler() { 
	PORT_START(); 	/* DSW */
		PORT_DIPNAME( 0x01, 0x00, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x01, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x00, DEF_STR( "On") );
		PORT_DIPNAME( 0x02, 0x00, DEF_STR( "Bonus_Life") );
		PORT_DIPSETTING(    0x00, "10000" );	PORT_DIPSETTING(    0x02, "12000" );	PORT_DIPNAME( 0x08, 0x00, "Allow Round Select" );	PORT_DIPSETTING(    0x00, DEF_STR( "No") );
		PORT_DIPSETTING(    0x08, DEF_STR( "Yes") );
		PORT_DIPNAME( 0x14, 0x00, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x04, DEF_STR( "2C_1C") );
		PORT_DIPSETTING(    0x00, DEF_STR( "1C_1C") );
		PORT_DIPSETTING(    0x10, DEF_STR( "1C_2C") );
		PORT_DIPSETTING(    0x14, DEF_STR( "Free_Play") );
		PORT_DIPNAME( 0x20, 0x00, DEF_STR( "Lives") );
		PORT_DIPSETTING(    0x00, "3" );	PORT_DIPSETTING(    0x20, "5" );	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( "Difficulty") );
		PORT_DIPSETTING(    0x40, "Easy" );	PORT_DIPSETTING(    0x00, "Medium" );	PORT_DIPSETTING(    0x80, "Hard" );	PORT_DIPSETTING(    0xc0, "Hardest" );
		PORT_START(); 	/* IN1 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x3c, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BITX(0x40, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_SERVICE( 0x80, IP_ACTIVE_LOW );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V (dial) */
		PORT_ANALOGX( 0xff, 0x00, IPT_DIAL, 5, 10, 0, 0, KEYCODE_Z, KEYCODE_X, 0, 0 );
		PORT_START(); 	/* IN3 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_8WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_START1 );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START2 );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_BUTTON2 );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_qbert = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW */
		PORT_DIPNAME( 0x01, 0x00, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x01, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x00, DEF_STR( "On") );
		PORT_DIPNAME( 0x02, 0x02, "Kicker" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x02, DEF_STR( "On") );
		PORT_DIPNAME( 0x04, 0x00, DEF_STR( "Cabinet") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Upright") );
		PORT_DIPSETTING(    0x04, DEF_STR( "Cocktail") );
		PORT_BITX( 0x08, 0x00, IPT_DIPSWITCH_NAME | IPF_CHEAT, "Auto Round Advance", IP_KEY_NONE, IP_JOY_NONE );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x08, DEF_STR( "On") );
		PORT_DIPNAME( 0x10, 0x00, DEF_STR( "Free_Play") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x10, DEF_STR( "On") );
		PORT_DIPNAME( 0x20, 0x00, "SW5" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x20, DEF_STR( "On") );
		PORT_DIPNAME( 0x40, 0x00, "SW7" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x40, DEF_STR( "On") );
		PORT_DIPNAME( 0x80, 0x00, "SW8" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x80, DEF_STR( "On") );
		PORT_BIT( 0xe0, IP_ACTIVE_LOW, IPT_UNUSED );/* 0x40 must be connected to the IP16 line */
	
		PORT_START();       /* buttons */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_SERVICE( 0x40, IP_ACTIVE_LOW );	PORT_BITX(0x80, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* joystick */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_4WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_4WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_4WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_4WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_4WAY | IPF_COCKTAIL );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_4WAY | IPF_COCKTAIL );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_4WAY | IPF_COCKTAIL );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_4WAY | IPF_COCKTAIL );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_qbertqub = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW */
		PORT_DIPNAME( 0x08, 0x00, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x08, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x00, DEF_STR( "On") );
		PORT_DIPNAME( 0x35, 0x00, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x24, "A 2/1 B 2/1" );	PORT_DIPSETTING(    0x14, "A 1/1 B 4/1" );	PORT_DIPSETTING(    0x30, "A 1/1 B 3/1" );	PORT_DIPSETTING(    0x10, "A 1/1 B 2/1" );	PORT_DIPSETTING(    0x00, "A 1/1 B 1/1" );	PORT_DIPSETTING(    0x11, "A 2/3 B 2/1" );	PORT_DIPSETTING(    0x15, "A 1/2 B 3/1" );	PORT_DIPSETTING(    0x20, "A 1/2 B 2/1" );	PORT_DIPSETTING(    0x21, "A 1/2 B 1/1" );	PORT_DIPSETTING(    0x31, "A 1/2 B 1/5" );	PORT_DIPSETTING(    0x04, "A 1/3 B 2/1" );	PORT_DIPSETTING(    0x05, "A 1/3 B 1/1" );	PORT_DIPSETTING(    0x35, DEF_STR( "Free_Play") );
	/* 0x25 DEF_STR( 2C_1C )
	   0x01 DEF_STR( 1C_1C )
	   0x34 DEF_STR( Free_Play ) */
		PORT_DIPNAME( 0x02, 0x00, "1st Bonus Life" );	PORT_DIPSETTING(    0x00, "10000" );	PORT_DIPSETTING(    0x02, "15000" );	PORT_DIPNAME( 0x40, 0x00, "Additional Bonus Life" );	PORT_DIPSETTING(    0x00, "20000" );	PORT_DIPSETTING(    0x40, "25000" );	PORT_DIPNAME( 0x80, 0x00, DEF_STR( "Difficulty") );
		PORT_DIPSETTING(    0x00, "Normal" );	PORT_DIPSETTING(    0x80, "Hard" );
		PORT_START();       /* buttons */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_SERVICE( 0x40, IP_ACTIVE_LOW );	PORT_BITX(0x80, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* joystick */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_4WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_4WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_4WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_4WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_krull = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW0 */
		PORT_DIPNAME( 0x01, 0x00, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x01, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x00, DEF_STR( "On") );
		PORT_DIPNAME( 0x02, 0x00, DEF_STR( "Difficulty") );
		PORT_DIPSETTING(    0x00, "Normal" );	PORT_DIPSETTING(    0x02, "Hard" );	PORT_DIPNAME( 0x08, 0x00, DEF_STR( "Lives") );
		PORT_DIPSETTING(    0x00, "3" );	PORT_DIPSETTING(    0x08, "5" );	PORT_DIPNAME( 0x14, 0x00, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x04, DEF_STR( "2C_1C") );
		PORT_DIPSETTING(    0x00, DEF_STR( "1C_1C") );
		PORT_DIPSETTING(    0x10, DEF_STR( "1C_2C") );
		PORT_DIPSETTING(    0x14, DEF_STR( "Free_Play") );
		PORT_DIPNAME( 0x20, 0x00, "Hexagon" );	PORT_DIPSETTING(    0x00, "Roving" );	PORT_DIPSETTING(    0x20, "Stationary" );	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( "Bonus_Life") );
		PORT_DIPSETTING(    0x40, "30000 30000" );	PORT_DIPSETTING(    0x00, "30000 50000" );	PORT_DIPSETTING(    0x80, "40000 50000" );	PORT_DIPSETTING(    0xc0, "50000 75000" );
		PORT_START();       /* IN0 */
		PORT_SERVICE( 0x01, IP_ACTIVE_LOW );	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START1 );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_START2 );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* IN3 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_UP    | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_RIGHT | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_DOWN  | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_LEFT  | IPF_8WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_UP     | IPF_8WAY );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_RIGHT  | IPF_8WAY );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_DOWN   | IPF_8WAY );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_LEFT   | IPF_8WAY );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_mach3 = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW0 */
		/* TODO: values are different for 5 lives */
		PORT_DIPNAME( 0x09, 0x08, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x09, DEF_STR( "4C_1C") );
		PORT_DIPSETTING(    0x01, DEF_STR( "3C_1C") );
		PORT_DIPSETTING(    0x08, DEF_STR( "2C_1C") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Free_Play") );
		PORT_DIPNAME( 0x02, 0x00, DEF_STR( "Difficulty") );
		PORT_DIPSETTING(    0x00, "Normal" );	PORT_DIPSETTING(    0x02, "Hard" );	PORT_DIPNAME( 0x10, 0x00, DEF_STR( "Lives") );
		PORT_DIPSETTING(    0x00, "3" );	PORT_DIPSETTING(    0x10, "5" );	PORT_DIPNAME( 0x24, 0x00, DEF_STR( "Bonus_Life") );
		PORT_DIPSETTING(    0x00, "10000 10000" );	PORT_DIPSETTING(    0x04, "10000 20000" );	PORT_DIPSETTING(    0x20, "10000 40000" );	PORT_DIPSETTING(    0x24, "20000 60000" );	PORT_DIPNAME( 0x40, 0x40, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x40, DEF_STR( "On") );
		PORT_BITX(    0x80, 0x80, IPT_DIPSWITCH_NAME | IPF_CHEAT, "Infinite Lives", IP_KEY_NONE, IP_JOY_NONE );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x80, DEF_STR( "On") );
	
		PORT_START();       /* IN0 */
		PORT_SERVICE( 0x01, IP_ACTIVE_LOW );	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_TILT );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START1 );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_START2 );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* IN3 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_usvsthem = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW0 */
		/* TODO: values are different for 5 lives */
		PORT_DIPNAME( 0x09, 0x00, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x08, DEF_STR( "2C_1C") );
		PORT_DIPSETTING(    0x00, DEF_STR( "1C_1C") );
		PORT_DIPSETTING(    0x01, DEF_STR( "Free_Play") );
	/*	PORT_DIPSETTING(    0x09, DEF_STR( "Free_Play") ); */
		PORT_DIPNAME( 0x02, 0x00, DEF_STR( "Unknown") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x02, DEF_STR( "On") );
		PORT_DIPNAME( 0x04, 0x00, DEF_STR( "Difficulty") );
		PORT_DIPSETTING(    0x00, "Normal" );	PORT_DIPSETTING(    0x04, "Hard" );	PORT_DIPNAME( 0x10, 0x00, DEF_STR( "Unknown") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x10, DEF_STR( "On") );
		PORT_DIPNAME( 0x20, 0x00, DEF_STR( "Unknown") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x20, DEF_STR( "On") );
		PORT_DIPNAME( 0x40, 0x00, DEF_STR( "Unknown") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x40, DEF_STR( "On") );
		PORT_DIPNAME( 0x80, 0x00, DEF_STR( "Unknown") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x80, DEF_STR( "On") );
	
		PORT_START();       /* IN0 */
		PORT_SERVICE( 0x01, IP_ACTIVE_LOW );	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_TILT );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START1 );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_START2 );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* IN3 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON3 );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_3stooges = new InputPortPtr(){ public void handler() { 
	PORT_START(); 	/* DSW */
		PORT_DIPNAME (0x01, 0x00, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING (   0x01, DEF_STR( "Off") );
		PORT_DIPSETTING (   0x00, DEF_STR( "On") );
		PORT_DIPNAME (0x02, 0x00, DEF_STR( "Difficulty") );
		PORT_DIPSETTING (   0x00, "Normal" );	PORT_DIPSETTING (   0x02, "Hard" );	PORT_DIPNAME (0x08, 0x00, DEF_STR( "Lives") );
		PORT_DIPSETTING (   0x00, "3" );	PORT_DIPSETTING (   0x08, "5" );	PORT_DIPNAME (0x14, 0x00, DEF_STR( "Coinage") );
		PORT_DIPSETTING (   0x04, DEF_STR( "2C_1C") );
		PORT_DIPSETTING (   0x00, DEF_STR( "1C_1C") );
		PORT_DIPSETTING (   0x10, DEF_STR( "1C_2C") );
		PORT_DIPSETTING (   0x14, DEF_STR( "Free_Play") );
		PORT_DIPNAME( 0x20, 0x00, DEF_STR( "Unknown") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x20, DEF_STR( "On") );
		PORT_DIPNAME (0x40, 0x00, "1st Bonus Life at" );	PORT_DIPSETTING (   0x40, "10000" );	PORT_DIPSETTING (   0x00, "20000" );	PORT_DIPNAME (0x80, 0x00, "And Bonus Life Every" );	PORT_DIPSETTING (   0x80, "10000" );	PORT_DIPSETTING (   0x00, "20000" );
		PORT_START(); 	/* IN1 */
		PORT_SERVICE( 0x01, IP_ACTIVE_LOW );	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_TILT );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* joystick 2 (Moe) */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_PLAYER2 | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_PLAYER2 | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_PLAYER2 | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_PLAYER2 | IPF_8WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER2 );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER1 );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER3 );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );
		/* the bottom four bits of the previous port are multiplexed among */
		/* three joysticks - the following port contains settings for the other two */
		PORT_START(); 
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_PLAYER3 | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_PLAYER3 | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_PLAYER3 | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_PLAYER3 | IPF_8WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_PLAYER1 | IPF_8WAY );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_PLAYER1 | IPF_8WAY );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_PLAYER1 | IPF_8WAY );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_PLAYER1 | IPF_8WAY );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_curvebal = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW0 */
		PORT_DIPNAME( 0x08, 0x00, "2 Players Game" );	PORT_DIPSETTING(    0x08, "1 Credit" );	PORT_DIPSETTING(    0x00, "2 Credits" );	PORT_DIPNAME( 0x11, 0x00, DEF_STR( "Difficulty") );
		PORT_DIPSETTING(    0x00, "Easy" );	PORT_DIPSETTING(    0x10, "Medium" );	PORT_DIPSETTING(    0x01, "Hard" );	PORT_DIPSETTING(    0x11, "Hardest" );	PORT_DIPNAME( 0x04, 0x04, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x04, DEF_STR( "On") );
		PORT_DIPNAME( 0x20, 0x00, "Coins" );	PORT_DIPSETTING(    0x00, "Normal" );	PORT_DIPSETTING(    0x20, "French" );	/* TODO: coinage is different when French is selected */
	/* PORT_DIPNAME( 0xc2, 0x00, "French Coinage" );PORT_DIPSETTING(    0x42, "A 3/1 B 1/2" );PORT_DIPSETTING(    0x82, "A 1/5 B 1/2" );PORT_DIPSETTING(    0x02, "A 2/1 B 2/3" );PORT_DIPSETTING(    0xc0, "A 2/1 B 2/1" );PORT_DIPSETTING(    0x80, "A 1/1 B 1/2" );PORT_DIPSETTING(    0x40, "A 1/1 B 1/3" );PORT_DIPSETTING(    0x00, "A 1/1 B 1/1" );PORT_DIPSETTING(    0xc2, DEF_STR( "Free_Play") ); */
		PORT_DIPNAME( 0xc2, 0x00, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x42, "A 4/1 B 1/1" );	PORT_DIPSETTING(    0x82, "A 3/1 B 1/1" );	PORT_DIPSETTING(    0x02, "A 2/1 B 1/1" );	PORT_DIPSETTING(    0xc0, "A 2/1 B 2/1" );	PORT_DIPSETTING(    0x80, "A 2/1 B 1/2" );	PORT_DIPSETTING(    0x40, "A 2/1 B 1/3" );	PORT_DIPSETTING(    0x00, "A 1/1 B 1/1" );	PORT_DIPSETTING(    0xc2, DEF_STR( "Free_Play") );
	
		PORT_START();       /* IN0 */
		PORT_SERVICE( 0x01, IP_ACTIVE_LOW );	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* IN3 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER1, "Swing", IP_KEY_DEFAULT, IP_JOY_DEFAULT );	PORT_BITX(0x04, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER2, "Pitch Left", IP_KEY_DEFAULT, IP_JOY_DEFAULT );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BITX(0x10, IP_ACTIVE_HIGH, IPT_BUTTON2 | IPF_PLAYER2, "Pitch Right", IP_KEY_DEFAULT, IP_JOY_DEFAULT );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BITX(0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 | IPF_PLAYER1, "Bunt", IP_KEY_DEFAULT, IP_JOY_DEFAULT );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_screwloo = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW0 */
		PORT_DIPNAME( 0x01, 0x00, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x01, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x00, DEF_STR( "On") );
		PORT_DIPNAME( 0x02, 0x00, "Demo mode" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x02, DEF_STR( "On") );
		PORT_DIPNAME( 0x04, 0x00, "1st Bonus Atom at" );	PORT_DIPSETTING(    0x00, "5000" );	PORT_DIPSETTING(    0x04, "20000" );	PORT_DIPNAME( 0x08, 0x00, DEF_STR( "Free_Play") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x08, DEF_STR( "On") );
		PORT_DIPNAME( 0x50, 0x40, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x00, DEF_STR( "2C_1C") );
		PORT_DIPSETTING(    0x10, DEF_STR( "2C_2C") );
		PORT_DIPSETTING(    0x40, DEF_STR( "1C_1C") );
		PORT_DIPSETTING(    0x50, DEF_STR( "1C_2C") );
		PORT_DIPNAME( 0x20, 0x00, "1st Bonus Hand at" );	PORT_DIPSETTING(    0x00, "25000" );	PORT_DIPSETTING(    0x20, "50000" );	PORT_DIPNAME( 0x80, 0x00, "Hands" );	PORT_DIPSETTING(    0x00, "3" );	PORT_DIPSETTING(    0x80, "5" );
		PORT_START();       /* IN0 */
		PORT_SERVICE( 0x01, IP_ACTIVE_LOW );	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", KEYCODE_F1, IP_JOY_NONE );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_RIGHT | IPF_8WAY );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_LEFT  | IPF_8WAY );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_DOWN  | IPF_8WAY );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_UP    | IPF_8WAY );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* IN3 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_RIGHT | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_LEFT  | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_DOWN  | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_UP    | IPF_8WAY );	PORT_BITX(0x10, IP_ACTIVE_HIGH, IPT_BUTTON2 | IPF_PLAYER1, "Start 2P", IP_KEY_DEFAULT, IP_JOY_DEFAULT );	PORT_BITX(0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER1, "Start 1P", IP_KEY_DEFAULT, IP_JOY_DEFAULT );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );INPUT_PORTS_END(); }}; 
	
	static InputPortPtr input_ports_insector = new InputPortPtr(){ public void handler() { 
	PORT_START();       /* DSW0 */
		PORT_DIPNAME( 0x01, 0x00, DEF_STR( "Bonus_Life") );
		PORT_DIPSETTING(    0x00, "25000" );	PORT_DIPSETTING(    0x01, "30000" );	PORT_DIPNAME( 0x02, 0x00, DEF_STR( "Demo_Sounds") );
		PORT_DIPSETTING(    0x02, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x00, DEF_STR( "On") );
		PORT_DIPNAME( 0x04, 0x00, "Demo mode" );	PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x04, DEF_STR( "On") );
		PORT_DIPNAME( 0x08, 0x08, DEF_STR( "Lives") );
		PORT_DIPSETTING(    0x08, "3" );	PORT_DIPSETTING(    0x00, "5" );	PORT_DIPNAME( 0x50, 0x00, DEF_STR( "Coinage") );
		PORT_DIPSETTING(    0x40, DEF_STR( "2C_1C") );
		PORT_DIPSETTING(    0x50, DEF_STR( "2C_2C") );
		PORT_DIPSETTING(    0x00, DEF_STR( "1C_1C") );
		PORT_DIPSETTING(    0x10, DEF_STR( "1C_2C") );
		PORT_DIPNAME( 0x20, 0x00, DEF_STR( "Free_Play") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Off") );
		PORT_DIPSETTING(    0x20, DEF_STR( "On") );
		PORT_DIPNAME( 0x80, 0x00, DEF_STR( "Cabinet") );
		PORT_DIPSETTING(    0x00, DEF_STR( "Upright") );
		PORT_DIPSETTING(    0x80, DEF_STR( "Cocktail") );
	
		PORT_START();       /* IN0 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_COCKTAIL );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 | IPF_COCKTAIL );	PORT_SERVICE( 0x40, IP_ACTIVE_LOW );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN );
		PORT_START(); 	/* trackball H not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START(); 	/* trackball V not used */
		PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED );
		PORT_START();       /* IN3 */
		PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_8WAY );	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY );	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_8WAY );	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_8WAY );	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    | IPF_8WAY | IPF_COCKTAIL );	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY | IPF_COCKTAIL );	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  | IPF_8WAY | IPF_COCKTAIL );	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  | IPF_8WAY | IPF_COCKTAIL );INPUT_PORTS_END(); }}; 
	
	
	
	/* the games can store char gfx data in either a 4k RAM area (128 chars), or */
	/* a 8k ROM area (256 chars). */
	static GfxLayout charRAMlayout = new GfxLayout
	(
		8,8,    /* 8*8 characters */
		128,    /* 128 characters */
		4,      /* 4 bits per pixel */
		new int[] { 0, 1, 2, 3 },
		new int[] { 0, 4, 8, 12, 16, 20, 24, 28},
		new int[] { 0*32, 1*32, 2*32, 3*32, 4*32, 5*32, 6*32, 7*32 },
		32*8    /* every char takes 32 consecutive bytes */
	);
	
	static GfxLayout charROMlayout = new GfxLayout
	(
		8,8,    /* 8*8 characters */
		256,    /* 256 characters */
		4,      /* 4 bits per pixel */
		new int[] { 0, 1, 2, 3 },
		new int[] { 0, 4, 8, 12, 16, 20, 24, 28},
		new int[] { 0*32, 1*32, 2*32, 3*32, 4*32, 5*32, 6*32, 7*32 },
		32*8    /* every char takes 32 consecutive bytes */
	);
	
	static GfxLayout spritelayout = new GfxLayout
	(
		16,16,
		RGN_FRAC(1,4),
		4,      /* 4 bits per pixel */
		new int[] { RGN_FRAC(0,4), RGN_FRAC(1,4), RGN_FRAC(2,4), RGN_FRAC(3,4) },
		new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
		new int[] { 0*16, 1*16, 2*16, 3*16, 4*16, 5*16, 6*16, 7*16,
				8*16, 9*16, 10*16, 11*16, 12*16, 13*16, 14*16, 15*16 },
		32*8
	);
	
	static GfxDecodeInfo charRAM_gfxdecodeinfo[] =
	{
		new GfxDecodeInfo( 0,           0x4000, charRAMlayout, 0, 1 ),	/* the game dynamically modifies this */
		new GfxDecodeInfo( REGION_GFX2, 0x0000, spritelayout,  0, 1 ),
		new GfxDecodeInfo( -1 ) /* end of array */
	};
	
	static GfxDecodeInfo charROM_gfxdecodeinfo[] =
	{
		new GfxDecodeInfo( REGION_GFX1, 0x0000, charROMlayout, 0, 1 ),
		new GfxDecodeInfo( REGION_GFX2, 0x0000, spritelayout,  0, 1 ),
		new GfxDecodeInfo( -1 ) /* end of array */
	};
	
	
	
	static DACinterface dac1_interface = new DACinterface
	(
		1,
		new int[] { 50 }
	);
	
	static DACinterface dac2_interface = new DACinterface
	(
		2,
		new int[] { 25, 25 }
	);
	
	static const char *reactor_sample_names[] =
	{
		"*reactor",
		"fx_53.wav", /* "8 left" */
		"fx_54.wav", /* "16 left" */
		"fx_55.wav", /* "24 left" */
		"fx_56.wav", /* "32 left" */
		"fx_57.wav", /* "40 left" */
		"fx_58.wav", /* "warning, core unstable" */
		"fx_59.wav", /* "bonus" */
		"fx_31.wav", /* "chamber activated" */
		"fx_39a.wav", /* "2000" */
		"fx_39b.wav", /* "5000" */
		"fx_39c.wav", /* "10000" */
		"fx_39d.wav", /* "15000" */
		"fx_39e.wav", /* "20000" */
		"fx_39f.wav", /* "25000" */
		"fx_39g.wav", /* "30000" */
		"fx_39h.wav", /* "35000" */
		"fx_39i.wav", /* "40000" */
		"fx_39j.wav", /* "45000" */
		"fx_39k.wav", /* "50000" */
		"fx_39l.wav", /* "55000" */
	     0	/* end of array */
	};
	
	static const char *qbert_sample_names[] =
	{
		"*qbert",
		"fx_17a.wav", /* random speech, voice clock 255 */
		"fx_17b.wav", /* random speech, voice clock 255 */
		"fx_17c.wav", /* random speech, voice clock 255 */
		"fx_17d.wav", /* random speech, voice clock 255 */
		"fx_17e.wav", /* random speech, voice clock 255 */
		"fx_17f.wav", /* random speech, voice clock 255 */
		"fx_17g.wav", /* random speech, voice clock 255 */
		"fx_17h.wav", /* random speech, voice clock 255 */
		"fx_18a.wav", /* random speech, voice clock 176 */
		"fx_18b.wav", /* random speech, voice clock 176 */
		"fx_18c.wav", /* random speech, voice clock 176 */
		"fx_18d.wav", /* random speech, voice clock 176 */
		"fx_18e.wav", /* random speech, voice clock 176 */
		"fx_18f.wav", /* random speech, voice clock 176 */
		"fx_18g.wav", /* random speech, voice clock 176 */
		"fx_18h.wav", /* random speech, voice clock 176 */
		"fx_19a.wav", /* random speech, voice clock 128 */
		"fx_19b.wav", /* random speech, voice clock 128 */
		"fx_19c.wav", /* random speech, voice clock 128 */
		"fx_19d.wav", /* random speech, voice clock 128 */
		"fx_19e.wav", /* random speech, voice clock 128 */
		"fx_19f.wav", /* random speech, voice clock 128 */
		"fx_19g.wav", /* random speech, voice clock 128 */
		"fx_19h.wav", /* random speech, voice clock 128 */
		"fx_20a.wav", /* random speech, voice clock 96 */
		"fx_20b.wav", /* random speech, voice clock 96 */
		"fx_20c.wav", /* random speech, voice clock 96 */
		"fx_20d.wav", /* random speech, voice clock 96 */
		"fx_20e.wav", /* random speech, voice clock 96 */
		"fx_20f.wav", /* random speech, voice clock 96 */
		"fx_20g.wav", /* random speech, voice clock 96 */
		"fx_20h.wav", /* random speech, voice clock 96 */
		"fx_21a.wav", /* random speech, voice clock 62 */
		"fx_21b.wav", /* random speech, voice clock 62 */
		"fx_21c.wav", /* random speech, voice clock 62 */
		"fx_21d.wav", /* random speech, voice clock 62 */
		"fx_21e.wav", /* random speech, voice clock 62 */
		"fx_21f.wav", /* random speech, voice clock 62 */
		"fx_21g.wav", /* random speech, voice clock 62 */
		"fx_21h.wav", /* random speech, voice clock 62 */
		"fx_22.wav", /* EH2 with decreasing voice clock */
		"fx_23.wav", /* O1 with varying voice clock */
		"fx_28.wav", /* "hello, I'm ready" */
		"fx_36.wav", /* "byebye" */
		"knocker.wav",
		0	/* end of array */
	};
	
	static Samplesinterface qbert_samples_interface = new Samplesinterface
	(
	 	1,	/* one channel */
		100,	/* volume */
		qbert_sample_names
	);
	
	static Samplesinterface reactor_samples_interface = new Samplesinterface
	(
		1,	/* one channel */
		100,	/* volume */
		reactor_sample_names
	);
	
	#define gottlieb_samples_interface qbert_samples_interface	/* not used */
	#define krull_samples_interface qbert_samples_interface		/* not used */
	
	
	static AY8910interface ay8910_interface = new AY8910interface
	(
		2,	/* 2 chips */
		2000000,	/* 2 MHz */
		new int[] { 25, 25 },
		new ReadHandlerPtr[] { 0 },
		new ReadHandlerPtr[] { 0 },
		new WriteHandlerPtr[] { 0 },
		new WriteHandlerPtr[] { 0 }
	);
	
	
	
	/********************************************************************
	*
	*  Machine Driver macro
	*  ====================
	*
	*  There are two versions of the machine driver,
	*  one for revision 1 sound board (1x6502 + DAC + Votrax),
	*  one for revision 2 (2x6502 + DAC + GI SP-0250 speech chip + 2x8910).
	*  They are identical apart form the sound CPU subsections.
	*
	********************************************************************/
	
	#define MACHINE_DRIVER_SOUND_1(GAMENAME,READMEM,WRITEMEM,GFX,NVRAM,SAMPLES)	\
	static MachineDriver machine_driver_##GAMENAME = new MachineDriver\
	(                                                                   \
		/* basic machine hardware */                                	\
		new MachineCPU[] {		                                                        \
			new MachineCPU(	  	                                                    \
				CPU_I86,												\
				5000000,        /* 5 MHz */								\
				READMEM,WRITEMEM,null,null,									\
				gottlieb_interrupt,1									\
			),		                                                    \
			new MachineCPU(		                                                    \
				CPU_M6502 | CPU_AUDIO_CPU ,								\
				3579545/4,	/* the board can be set to /2 as well */	\
				gottlieb_sound_readmem,gottlieb_sound_writemem,null,null,		\
				ignore_interrupt,1	/* IRQs are triggered by the main CPU */		\
									/* NMIs are triggered by the Votrax SC-01 */	\
			)                                                   		\
		},                                                          	\
		61, 1018,	/* frames per second, vblank duration */			\
		1,	/* 1 CPU slice per frame - interleaving is forced when a sound command is written */ \
		init_machine,			                                    	\
																		\
		/* video hardware */                                        	\
		32*8, 32*8, new rectangle( 0*8, 32*8-1, 0*8, 30*8-1 ),						\
		GFX,                                                        	\
		16, 16,		                                                	\
		null,									                           	\
																		\
		VIDEO_TYPE_RASTER | VIDEO_MODIFIES_PALETTE,						\
		null,                                                          	\
		gottlieb_vh_start,												\
		gottlieb_vh_stop,												\
		gottlieb_vh_screenrefresh,										\
																		\
		/* sound hardware */                                        	\
		0,0,0,0,                                                    	\
		new MachineSound[] {                                                           	\
			new MachineSound(                                                   		\
				SOUND_DAC,												\
				dac1_interface											\
			),															\
			new MachineSound(															\
				SAMPLES * SOUND_SAMPLES,	/* for Votrax simulation */	\
				GAMENAME##_samples_interface							\
			)                                                   		\
		},                                                           	\
																		\
		NVRAM															\
	)
	
	#define MACHINE_DRIVER_SOUND_2(GAMENAME,READMEM,WRITEMEM,GFX,NVRAM)	\
	static MachineDriver machine_driver_##GAMENAME = new MachineDriver\
	(																	\
		/* basic machine hardware */									\
		new MachineCPU[] {																\
			new MachineCPU(															\
				CPU_I86,												\
				5000000,        /* 5 MHz */								\
				READMEM,WRITEMEM,null,null,									\
				gottlieb_interrupt,1									\
			),															\
			new MachineCPU(															\
				CPU_M6502 | CPU_AUDIO_CPU ,								\
				1000000,	/* 1 MHz */									\
				stooges_sound_readmem,stooges_sound_writemem,null,null,		\
				ignore_interrupt,1	/* IRQs are triggered by the main CPU */			\
									/* NMIs are triggered by the second sound CPU */	\
			),															\
			new MachineCPU(															\
				CPU_M6502 | CPU_AUDIO_CPU ,								\
				1000000,	/* 1 MHz */									\
				stooges_sound2_readmem,stooges_sound2_writemem,null,null,		\
				ignore_interrupt,1	/* IRQs are triggered by the main CPU */			\
									/* NMIs are triggered by a programmable timer */	\
			)															\
		},																\
		61, 1018,	/* frames per second, vblank duration */			\
		1,	/* 1 CPU slice per frame - interleaving is forced when a sound command is written */ \
		init_machine,													\
																		\
		/* video hardware */											\
		32*8, 32*8, new rectangle( 0*8, 32*8-1, 0*8, 30*8-1 ),						\
		GFX,															\
		16, 16,															\
		null,																\
																		\
		VIDEO_TYPE_RASTER | VIDEO_MODIFIES_PALETTE,						\
		null,																\
		gottlieb_vh_start,												\
		gottlieb_vh_stop,												\
		gottlieb_vh_screenrefresh,										\
																		\
		/* sound hardware */											\
		0,0,0,0,														\
		new MachineSound[] {																\
			new MachineSound(															\
				SOUND_DAC,												\
				dac2_interface											\
			),															\
			new MachineSound(															\
				SOUND_AY8910,											\
				ay8910_interface										\
			)															\
		},																\
																		\
		NVRAM															\
	)
	
	/* games using the revision 1 sound board */
	MACHINE_DRIVER_SOUND_1(reactor,  reactor_readmem, reactor_writemem, charRAM_gfxdecodeinfo,0,            1);
	MACHINE_DRIVER_SOUND_1(gottlieb, gottlieb_readmem,gottlieb_writemem,charROM_gfxdecodeinfo,nvram_handler,0);
	MACHINE_DRIVER_SOUND_1(qbert,    gottlieb_readmem,gottlieb_writemem,charROM_gfxdecodeinfo,nvram_handler,1);
	MACHINE_DRIVER_SOUND_1(krull,    gottlieb_readmem,gottlieb_writemem,charRAM_gfxdecodeinfo,nvram_handler,0);
	/* games using the revision 2 sound board */
	MACHINE_DRIVER_SOUND_2(mach3,    gottlieb_readmem,usvsthem_writemem,charROM_gfxdecodeinfo,nvram_handler);
	MACHINE_DRIVER_SOUND_2(usvsthem, gottlieb_readmem,usvsthem_writemem,charROM_gfxdecodeinfo,nvram_handler);
	MACHINE_DRIVER_SOUND_2(stooges,  stooges_readmem, stooges_writemem, charRAM_gfxdecodeinfo,nvram_handler);
	MACHINE_DRIVER_SOUND_2(gottlieb2,gottlieb_readmem,gottlieb_writemem,charROM_gfxdecodeinfo,nvram_handler);
	
	
	/***************************************************************************
	
	  Game driver(s)
	
	***************************************************************************/
	
	static RomLoadPtr rom_reactor = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "rom7",         0x8000, 0x1000, 0xa62d86fd );	ROM_LOAD( "rom6",         0x9000, 0x1000, 0x6ed841f3 );	ROM_LOAD( "rom5",         0xa000, 0x1000, 0xd90576a3 );	ROM_LOAD( "rom4",         0xb000, 0x1000, 0x0155daae );	ROM_LOAD( "rom3",         0xc000, 0x1000, 0xf8881385 );	ROM_LOAD( "rom2",         0xd000, 0x1000, 0x3caba35b );	ROM_LOAD( "rom1",         0xe000, 0x1000, 0x944e1ddf );	ROM_LOAD( "rom0",         0xf000, 0x1000, 0x55930aed );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "snd1",         0xf000, 0x800, 0xd958a0fd );	ROM_RELOAD(               0x7000, 0x800 );/* A15 is not decoded */
		ROM_LOAD( "snd2",         0xf800, 0x800, 0x5dc86942 );	ROM_RELOAD(               0x7800, 0x800 );/* A15 is not decoded */
	
		/* no gfx1 (RAM is used) */
	
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	/* 0000-0fff empty */
		ROM_LOAD( "fg3",          0x1000, 0x1000, 0x8416ad53 );/* sprites */
		/* 2000-2fff empty */
		ROM_LOAD( "fg2",          0x3000, 0x1000, 0x5489605a );	/* 4000-4fff empty */
		ROM_LOAD( "fg1",          0x5000, 0x1000, 0x18396c57 );	/* 6000-6fff empty */
		ROM_LOAD( "fg0",          0x7000, 0x1000, 0xd1f20e15 );ROM_END(); }}; 
	
	static RomLoadPtr rom_mplanets = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "rom4",         0x6000, 0x2000, 0x5402077f );	ROM_LOAD( "rom3",         0x8000, 0x2000, 0x5d18d740 );	ROM_LOAD( "rom2",         0xa000, 0x2000, 0x960c3bb1 );	ROM_LOAD( "rom1",         0xc000, 0x2000, 0xeb515f10 );	ROM_LOAD( "rom0",         0xe000, 0x2000, 0x74de78aa );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "snd1",         0xf000, 0x800, 0x453193a1 );	ROM_RELOAD(               0x7000, 0x800 );/* A15 is not decoded */
		ROM_LOAD( "snd2",         0xf800, 0x800, 0xf5ffc98f );	ROM_RELOAD(               0x7800, 0x800 );/* A15 is not decoded */
	
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "bg0",          0x0000, 0x1000, 0x709aa24c );/* chars */
		ROM_LOAD( "bg1",          0x1000, 0x1000, 0x4921e345 );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "fg3",          0x0000, 0x2000, 0xc990b39f );/* sprites */
		ROM_LOAD( "fg2",          0x2000, 0x2000, 0x735e2522 );	ROM_LOAD( "fg1",          0x4000, 0x2000, 0x6456cc1c );	ROM_LOAD( "fg0",          0x6000, 0x2000, 0xa920e325 );ROM_END(); }}; 
	
	static RomLoadPtr rom_qbert = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "qb-rom2.bin",  0xa000, 0x2000, 0xfe434526 );	ROM_LOAD( "qb-rom1.bin",  0xc000, 0x2000, 0x55635447 );	ROM_LOAD( "qb-rom0.bin",  0xe000, 0x2000, 0x8e318641 );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "qb-snd1.bin",  0xf000, 0x800, 0x15787c07 );	ROM_RELOAD(               0x7000, 0x800 );/* A15 is not decoded */
		ROM_LOAD( "qb-snd2.bin",  0xf800, 0x800, 0x58437508 );	ROM_RELOAD(               0x7800, 0x800 );/* A15 is not decoded */
	
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qb-bg0.bin",   0x0000, 0x1000, 0x7a9ba824 );/* chars */
		ROM_LOAD( "qb-bg1.bin",   0x1000, 0x1000, 0x22e5b891 );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qb-fg3.bin",   0x0000, 0x2000, 0xdd436d3a );/* sprites */
		ROM_LOAD( "qb-fg2.bin",   0x2000, 0x2000, 0xf69b9483 );	ROM_LOAD( "qb-fg1.bin",   0x4000, 0x2000, 0x224e8356 );	ROM_LOAD( "qb-fg0.bin",   0x6000, 0x2000, 0x2f695b85 );ROM_END(); }}; 
	
	static RomLoadPtr rom_qbertjp = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "qbj-rom2.bin", 0xa000, 0x2000, 0x67bb1cb2 );	ROM_LOAD( "qbj-rom1.bin", 0xc000, 0x2000, 0xc61216e7 );	ROM_LOAD( "qbj-rom0.bin", 0xe000, 0x2000, 0x69679d5c );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "qb-snd1.bin",  0xf000, 0x800, 0x15787c07 );	ROM_RELOAD(               0x7000, 0x800 );/* A15 is not decoded */
		ROM_LOAD( "qb-snd2.bin",  0xf800, 0x800, 0x58437508 );	ROM_RELOAD(               0x7800, 0x800 );/* A15 is not decoded */
	
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qb-bg0.bin",   0x0000, 0x1000, 0x7a9ba824 );/* chars */
		ROM_LOAD( "qb-bg1.bin",   0x1000, 0x1000, 0x22e5b891 );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qb-fg3.bin",   0x0000, 0x2000, 0xdd436d3a );/* sprites */
		ROM_LOAD( "qb-fg2.bin",   0x2000, 0x2000, 0xf69b9483 );	ROM_LOAD( "qb-fg1.bin",   0x4000, 0x2000, 0x224e8356 );	ROM_LOAD( "qb-fg0.bin",   0x6000, 0x2000, 0x2f695b85 );ROM_END(); }}; 
	
	static RomLoadPtr rom_insector = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "rom3",         0x8000, 0x2000, 0x640881fd );	ROM_LOAD( "rom2",         0xa000, 0x2000, 0x456bc3f4 );	ROM_LOAD( "rom1",         0xc000, 0x2000, 0x706962af );	ROM_LOAD( "rom0",         0xe000, 0x2000, 0x31cee24b );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "sound",        0xf000, 0x1000, 0x00000000 );
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "bg0",          0x0000, 0x1000, 0x0dc2037e );/* chars */
		ROM_LOAD( "bg1",          0x1000, 0x1000, 0x3dd73b94 );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "fg3",          0x0000, 0x2000, 0x9bbf5b6b );/* sprites */
		ROM_LOAD( "fg2",          0x2000, 0x2000, 0x5adf9986 );	ROM_LOAD( "fg1",          0x4000, 0x2000, 0x4bb16111 );	ROM_LOAD( "fg0",          0x6000, 0x2000, 0x965f6b76 );ROM_END(); }}; 
	
	static RomLoadPtr rom_screwloo = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "rom4",         0x6000, 0x2000, 0x744a2513 );	ROM_LOAD( "rom3",         0x8000, 0x2000, 0xffde5b5d );	ROM_LOAD( "rom2",         0xa000, 0x2000, 0x97932b05 );	ROM_LOAD( "rom1",         0xc000, 0x2000, 0x571b65ca );	ROM_LOAD( "rom0",         0xe000, 0x2000, 0x6447fe54 );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "drom1",        0xe000, 0x2000, 0xae965ade );
		ROM_REGION( 0x10000, REGION_CPU3 );/* 64k for second sound cpu */
		ROM_LOAD( "yrom1",        0xe000, 0x2000, 0x3719b0b5 );
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "bg0",          0x0000, 0x1000, 0x1fd5b649 );/* chars */
		ROM_LOAD( "bg1",          0x1000, 0x1000, 0xc8ddb8ba );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "fg3",          0x0000, 0x2000, 0x97d4e63b );/* sprites */
		ROM_LOAD( "fg2",          0x2000, 0x2000, 0xf76e56ca );	ROM_LOAD( "fg1",          0x4000, 0x2000, 0x698c395f );	ROM_LOAD( "fg0",          0x6000, 0x2000, 0xf23269fb );ROM_END(); }}; 
	
	static RomLoadPtr rom_sqbert = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "qb-rom2.bin",  0xa000, 0x2000, 0x1e3d4038 );	ROM_LOAD( "qb-rom1.bin",  0xc000, 0x2000, 0xeaf3076c );	ROM_LOAD( "qb-rom0.bin",  0xe000, 0x2000, 0x61260a7e );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "qb-snd1.bin",  0xf000, 0x800, 0x15787c07 );	ROM_RELOAD(               0x7000, 0x800 );/* A15 is not decoded */
		ROM_LOAD( "qb-snd2.bin",  0xf800, 0x800, 0x58437508 );	ROM_RELOAD(               0x7800, 0x800 );/* A15 is not decoded */
	
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qb-bg0.bin",   0x0000, 0x1000, 0xc3118eef );/* chars */
		ROM_LOAD( "qb-bg1.bin",   0x1000, 0x1000, 0x4f6d8075 );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qb-fg3.bin",   0x0000, 0x2000, 0xee595eda );/* sprites */
		ROM_LOAD( "qb-fg2.bin",   0x2000, 0x2000, 0x59884c78 );	ROM_LOAD( "qb-fg1.bin",   0x4000, 0x2000, 0x2a60e3ad );	ROM_LOAD( "qb-fg0.bin",   0x6000, 0x2000, 0xb11ad9d8 );ROM_END(); }}; 
	
	static RomLoadPtr rom_qbertqub = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "qq-rom3.bin",  0x8000, 0x2000, 0xc4dbdcd7 );	ROM_LOAD( "qq-rom2.bin",  0xa000, 0x2000, 0x21a6c6cc );	ROM_LOAD( "qq-rom1.bin",  0xc000, 0x2000, 0x63e6c43d );	ROM_LOAD( "qq-rom0.bin",  0xe000, 0x2000, 0x8ddbe438 );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "qb-snd1.bin",  0xf000, 0x800, 0x15787c07 );	ROM_RELOAD(               0x7000, 0x800 );/* A15 is not decoded */
		ROM_LOAD( "qb-snd2.bin",  0xf800, 0x800, 0x58437508 );	ROM_RELOAD(               0x7800, 0x800 );/* A15 is not decoded */
	
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qq-bg0.bin",   0x0000, 0x1000, 0x050badde );/* chars */
		ROM_LOAD( "qq-bg1.bin",   0x1000, 0x1000, 0x8875902f );
		ROM_REGION( 0x10000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "qq-fg3.bin",   0x0000, 0x4000, 0x91a949cc );/* sprites */
		ROM_LOAD( "qq-fg2.bin",   0x4000, 0x4000, 0x782d9431 );	ROM_LOAD( "qq-fg1.bin",   0x8000, 0x4000, 0x71c3ac4c );	ROM_LOAD( "qq-fg0.bin",   0xc000, 0x4000, 0x6192853f );ROM_END(); }}; 
	
	static RomLoadPtr rom_krull = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "ram2.bin",     0x1000, 0x1000, 0x302feadf );	ROM_LOAD( "ram4.bin",     0x2000, 0x1000, 0x79355a60 );	ROM_LOAD( "rom4.bin",     0x6000, 0x2000, 0x2b696394 );	ROM_LOAD( "rom3.bin",     0x8000, 0x2000, 0x14b0ee42 );	ROM_LOAD( "rom2.bin",     0xa000, 0x2000, 0xb5fad94a );	ROM_LOAD( "rom1.bin",     0xc000, 0x2000, 0x1ad956a3 );	ROM_LOAD( "rom0.bin",     0xe000, 0x2000, 0xa466afae );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "snd1.bin",     0xe000, 0x1000, 0xdd2b30b4 );	ROM_RELOAD(               0x6000, 0x1000 );/* A15 is not decoded */
		ROM_LOAD( "snd2.bin",     0xf000, 0x1000, 0x8cab901b );	ROM_RELOAD(               0x7000, 0x1000 );/* A15 is not decoded */
	
		/* no gfx1 (RAM is used) */
	
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "fg3.bin",      0x0000, 0x2000, 0x82d77a45 );/* sprites */
		ROM_LOAD( "fg2.bin",      0x2000, 0x2000, 0x25a24317 );	ROM_LOAD( "fg1.bin",      0x4000, 0x2000, 0x7e3ad7b0 );	ROM_LOAD( "fg0.bin",      0x6000, 0x2000, 0x7402dc19 );ROM_END(); }}; 
	
	static RomLoadPtr rom_mach3 = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );/* 64k for code */
		ROM_LOAD( "m3rom4.bin",   0x6000, 0x2000, 0x8bfd5a44 );	ROM_LOAD( "m3rom3.bin",   0x8000, 0x2000, 0xb1b045af );	ROM_LOAD( "m3rom2.bin",   0xa000, 0x2000, 0xfbdfb03d );	ROM_LOAD( "m3rom1.bin",   0xc000, 0x2000, 0x3b0ba80b );	ROM_LOAD( "m3rom0.bin",   0xe000, 0x2000, 0x70c12bf4 );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "m3drom1.bin",  0xf000, 0x1000, 0xa6e29212 );
		ROM_REGION( 0x10000, REGION_CPU3 );/* 64k for second sound cpu */
		ROM_LOAD( "m3yrom1.bin",  0xf000, 0x1000, 0xeddf8872 );
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "mach3bg0.bin", 0x0000, 0x1000, 0xea2f5257 );	ROM_LOAD( "mach3bg1.bin", 0x1000, 0x1000, 0xf543e4ce );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "mach3fg3.bin", 0x0000, 0x2000, 0x472128b4 );	ROM_LOAD( "mach3fg2.bin", 0x2000, 0x2000, 0x2a59e99e );	ROM_LOAD( "mach3fg1.bin", 0x4000, 0x2000, 0x9b88767b );	ROM_LOAD( "mach3fg0.bin", 0x6000, 0x2000, 0x0bae12a5 );ROM_END(); }}; 
	
	static RomLoadPtr rom_usvsthem = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );/* 64k for code */
		ROM_LOAD( "usvs.rm4",     0x6000, 0x2000, 0x0d7a4072 );	ROM_LOAD( "usvs.rm3",     0x8000, 0x2000, 0x6f32a671 );	ROM_LOAD( "usvs.rm2",     0xa000, 0x2000, 0x36770716 );	ROM_LOAD( "usvs.rm1",     0xc000, 0x2000, 0x697bc989 );	ROM_LOAD( "usvs.rm0",     0xe000, 0x2000, 0x30cf6bd9 );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "usvsdrom.1",   0xe000, 0x2000, 0xc0b5cab0 );
		ROM_REGION( 0x10000, REGION_CPU3 );/* 64k for second sound cpu */
		ROM_LOAD( "usvsyrom.1",   0xe000, 0x2000, 0xc3d245ca );
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "usvs.bg0",     0x0000, 0x1000, 0x8a0de09f );	ROM_LOAD( "usvs.bg1",     0x1000, 0x1000, 0x6fb64d3c );
		ROM_REGION( 0x10000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "usvs.fg3",     0x0000, 0x4000, 0x98703015 );	ROM_LOAD( "usvs.fg2",     0x4000, 0x4000, 0xd3990707 );	ROM_LOAD( "usvs.fg1",     0x8000, 0x4000, 0xa2057430 );	ROM_LOAD( "usvs.fg0",     0xc000, 0x4000, 0x7734e53f );ROM_END(); }}; 
	
	static RomLoadPtr rom_3stooges = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );    /* 64k for code */
		ROM_LOAD( "gv113ram.4",   0x2000, 0x1000, 0x533bff2a );	ROM_LOAD( "gv113rom.4",   0x6000, 0x2000, 0x8b6e52b8 );	ROM_LOAD( "gv113rom.3",   0x8000, 0x2000, 0xb816d8c4 );	ROM_LOAD( "gv113rom.2",   0xa000, 0x2000, 0xb45b2a79 );	ROM_LOAD( "gv113rom.1",   0xc000, 0x2000, 0x34ab051e );	ROM_LOAD( "gv113rom.0",   0xe000, 0x2000, 0xab124329 );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "drom1",        0xe000, 0x2000, 0x87a9fa10 );
		ROM_REGION( 0x10000, REGION_CPU3 );/* 64k for second sound cpu */
		ROM_LOAD( "yrom2",        0xc000, 0x2000, 0x90f9c940 );	ROM_LOAD( "yrom1",        0xe000, 0x2000, 0x55f8ab30 );
		/* no gfx1 (RAM is used) */
	
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "gv113fg3",     0x0000, 0x2000, 0x28071212 );/* sprites */
		ROM_LOAD( "gv113fg2",     0x2000, 0x2000, 0x9fa3dfde );	ROM_LOAD( "gv113fg1",     0x4000, 0x2000, 0xfb223854 );	ROM_LOAD( "gv113fg0",     0x6000, 0x2000, 0x95762c53 );ROM_END(); }}; 
	
	static RomLoadPtr rom_curvebal = new RomLoadPtr(){ public void handler(){ 
		ROM_REGION( 0x10000, REGION_CPU1 );/* 64k for code */
		ROM_LOAD( "cb-rom-3.chp", 0x8000, 0x2000, 0x72ad4d45 );	ROM_LOAD( "cb-rom-2.chp", 0xa000, 0x2000, 0xd46c3db5 );	ROM_LOAD( "cb-rom-1.chp", 0xc000, 0x2000, 0xeb1e08bd );	ROM_LOAD( "cb-rom-0.chp", 0xe000, 0x2000, 0x401fc7e3 );
		ROM_REGION( 0x10000, REGION_CPU2 );/* 64k for sound cpu */
		ROM_LOAD( "yrom.sbd",     0xe000, 0x1000, 0x4c313d9b );	ROM_LOAD( "drom.sbd",     0xf000, 0x1000, 0xcecece88 );
		ROM_REGION( 0x2000, REGION_GFX1 | REGIONFLAG_DISPOSE );	ROM_LOAD( "cb-bg-0.chp",  0x0000, 0x1000, 0xd666a179 );	ROM_LOAD( "cb-bg-1.chp",  0x1000, 0x1000, 0x5e34ff4e );
		ROM_REGION( 0x8000, REGION_GFX2 | REGIONFLAG_DISPOSE );	ROM_LOAD( "cb-fg-3.chp",  0x0000, 0x2000, 0x9c9452fe );	ROM_LOAD( "cb-fg-2.chp",  0x2000, 0x2000, 0x065131af );	ROM_LOAD( "cb-fg-1.chp",  0x4000, 0x2000, 0x1b7b7f94 );	ROM_LOAD( "cb-fg-0.chp",  0x6000, 0x2000, 0xe3a8230e );ROM_END(); }}; 
	
	
	static public static InitDriverPtr init_gottlieb = new InitDriverPtr() { public void handler() 
	{
		gottlieb_sound_init();
	} };
	
	
	public static GameDriver driver_reactor	   = new GameDriver("1982"	,"reactor"	,"gottlieb.java"	,rom_reactor,null	,machine_driver_reactor	,input_ports_reactor	,null	,ROT0	,	"Gottlieb", "Reactor" )
	public static GameDriver driver_mplanets	   = new GameDriver("1983"	,"mplanets"	,"gottlieb.java"	,rom_mplanets,null	,machine_driver_gottlieb	,input_ports_mplanets	,null	,ROT270	,	"Gottlieb", "Mad Planets" )
	public static GameDriver driver_qbert	   = new GameDriver("1982"	,"qbert"	,"gottlieb.java"	,rom_qbert,null	,machine_driver_qbert	,input_ports_qbert	,null	,ROT270	,	"Gottlieb", "Q*bert (US)" )
	public static GameDriver driver_qbertjp	   = new GameDriver("1982"	,"qbertjp"	,"gottlieb.java"	,rom_qbertjp,driver_qbert	,machine_driver_qbert	,input_ports_qbert	,null	,ROT270	,	"Gottlieb (Konami license)", "Q*bert (Japan)" )
	public static GameDriver driver_insector	   = new GameDriver("1982"	,"insector"	,"gottlieb.java"	,rom_insector,null	,machine_driver_gottlieb	,input_ports_insector	,null	,ROT0	,	"Gottlieb", "Insector (prototype)", GAME_NO_SOUND )
	public static GameDriver driver_krull	   = new GameDriver("1983"	,"krull"	,"gottlieb.java"	,rom_krull,null	,machine_driver_krull	,input_ports_krull	,null	,ROT270	,	"Gottlieb", "Krull" )
	public static GameDriver driver_sqbert	   = new GameDriver("1983"	,"sqbert"	,"gottlieb.java"	,rom_sqbert,null	,machine_driver_qbert	,input_ports_qbert	,null	,ROT270	,	"Mylstar", "Faster, Harder, More Challenging Q*bert (prototype)" )
	public static GameDriver driver_mach3	   = new GameDriver("1983"	,"mach3"	,"gottlieb.java"	,rom_mach3,null	,machine_driver_mach3	,input_ports_mach3	,init_gottlieb	,ROT0	,	"Mylstar", "M.A.C.H. 3", GAME_NOT_WORKING )
	public static GameDriver driver_usvsthem	   = new GameDriver("????"	,"usvsthem"	,"gottlieb.java"	,rom_usvsthem,null	,machine_driver_usvsthem	,input_ports_usvsthem	,init_gottlieb	,ROT0	,	"Mylstar", "Us vs. Them", GAME_NOT_WORKING )
	public static GameDriver driver_3stooges	   = new GameDriver("1984"	,"3stooges"	,"gottlieb.java"	,rom_3stooges,null	,machine_driver_stooges	,input_ports_3stooges	,init_gottlieb	,ROT0	,	"Mylstar", "Three Stooges", GAME_IMPERFECT_SOUND )
	public static GameDriver driver_qbertqub	   = new GameDriver("1983"	,"qbertqub"	,"gottlieb.java"	,rom_qbertqub,null	,machine_driver_qbert	,input_ports_qbertqub	,null	,ROT270	,	"Mylstar", "Q*bert's Qubes" )
	public static GameDriver driver_screwloo	   = new GameDriver("1983"	,"screwloo"	,"gottlieb.java"	,rom_screwloo,null	,machine_driver_gottlieb2	,input_ports_screwloo	,null	,ROT0	,	"Mylstar", "Screw Loose (prototype)" )
	public static GameDriver driver_curvebal	   = new GameDriver("1984"	,"curvebal"	,"gottlieb.java"	,rom_curvebal,null	,machine_driver_gottlieb	,input_ports_curvebal	,null	,ROT270	,	"Mylstar", "Curve Ball" )
}
